---
title: 'JVM 中对象的内存布局和访问定位'
date: '2022-06-19'
tags: ['jvm']
summary: ''
---

## 内存布局

![jvm-memory-layout](/static/images/blog/jvm/jvm-memory-layout.png)

在 HotSpot 虚拟机中，对象在内存中存储的布局可以分为 3 块区域：对象头（Object Header）、实例数据（Instance Data）和对齐填充（Padding）。

### 对象头（Object Header）

对象头在 HotSpot 虚拟机中被分为了两部分，一部分称为 Mark Word，另一部分是类型指针。如果对象是一个数组，那在对象头中还有一块用于记录数组长度的数据。

| 长度     | 内容                   | 描述                                                   |
| -------- | ---------------------- | ------------------------------------------------------ |
| 32/64bit | Mark Word              | 存储对象的 hashcode 、偏向锁模式、锁信息和 GC 分代年龄 |
| 32/64bit | Class Metadata Address | 存储对象指向它的类元数据的指针                         |
| 32/64bit | Array Length           | 数组长度（不一定有）                                   |

### 实例数据（Instance Data）

实例数据是对象真正存储的有效信息，也是在程序代码中所定义的对象的属性等信息。

### 对齐填充（Padding）

并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于 HotSpot VM 的自动内存管理系统要求对对象的大小必须是 **8 字节的整数倍**，当对象其他数据部分没有对齐时，就需要通过对齐填充来补全。

## 访问定位

Java 程序需要通过 JVM 栈上的引用访问堆中的具体对象。对象的访问方式取决于 JVM 虚拟机的实现。目前主流的访问方式有句柄和直接指针两种方式。

### 直接指针

指向对象，代表一个对象在内存中的起始地址。如果使用直接指针访问，引用中存储的直接就是对象地址，那么 Java 堆对象内部的布局中就必须考虑如何放置访问类型数据的相关信息。

![jvm-object-direct-pointer](/static/images/blog/jvm/jvm-object-direct-pointer.png)

优点：速度快，节省了一次指针定位的时间开销。由于对象的访问在 Java 中非常频繁，因此这类开销积少成多后也是非常可观的执行成本。HotSpot 中采用的就是这种方式。

### 句柄

可以理解为指向指针的指针，维护着对象的指针。句柄不直接指向对象，而是指向对象的指针（句柄不发生变化，指向固定内存地址），再由对象的指针指向对象的真实内存地址。如果使用直接句柄访问，Java 堆中划分出一块内存来作为句柄池，引用中存储对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。

![jvm-object-handle](/static/images/blog/jvm/jvm-object-handle.png)

优点：引用中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而引用本身不需要修改。
